redis是一个缓存中间件
是一个非结构性的数据库
通常以key-value的形式进行存储
高性能的内存数据库
Redis能读的速度是110000次/s,写的速度是81000次/s

redis之所以这么快，一方面是因为它是完全基于内存的，和数据库不一样，数据不是存放在磁盘里的
还有就是因为它虽然是单线程，但是是io多路复用的，非阻塞io（就不会存在多线程中的锁的概念了）

redis中的常见数据结构类型，string，set，zset，hash，list这几种类型

redis中常见的问题：
缓存雪崩：
缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
解决方案：（1)给缓存的失效时间，加上一个随机值，避免集体失效。 (2)使用互斥锁，但是该方案吞吐量明显下降了。
(3)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点
I 从缓存A读数据库，有则直接返回
II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。
III 更新线程同时更新缓存A和缓存B。

缓存穿透
缓存穿透，即黑客故意去请求缓存和数据库中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常
解决方案：（1）对空对象也进行缓存，但是效果不佳，比如为空的值很多，只有当一次请求后才会进行缓存
（2）使用布隆过滤器，提供一个能迅速判断请求是否有效的拦截机制，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。

缓存击穿
某个数据，缓存失效了，缓存中没有但是数据库中有，同时有大量的并发请求，导致数据库连接异常，严重可能导致数据库宕机


redis过期策略
定期删除+惰性删除策略（需要自己设置内存淘汰机制）
如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。
在redis.conf中有一行配置
# maxmemory-policy volatile-lru（redis.conf）